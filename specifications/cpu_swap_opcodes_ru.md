### Коды операций
###### скорее всего, расшифровку непонятного обозначения вы найдете внизу таблицы
| имя операции* | bf-ext инструкция | посл. байтов** | описние |
|--|--|--|--|
| PASS | not exist | 0x00 |do nothing|
| SET | **s** | **COM**: 0x01 **CEM**: SE | Устанавливает тек. порт в std_se_dec(SE) |
| READ | **r** | 0x02 | Считывает из тек. порта байт и записывает полученное значение в тек. ЯП. *Выполнение программы прекращается до считывания байта* |
| WR | **w** | 0x03 | Передает в тек. порт байт - значение тек. ЯП |
| TEST | **t** | 0x04 | Проверяет есть ли байт для считывания из тек. порта |
| SWAP | not exist | 0x05 | См. прим. SWAP. Нужно для реализации команд {.,48625@} без специальных для этого инструкций |
| INC | **+** | 0x10 | Увеличивает значение в тек. ЯП (CEM) на 1 |
| DEC | **-** | 0x11 | Уменьшает значение в тек. ЯП (CEM) на 1 |
| NEXTC | **>** | 0x12 | Сдвигает указатель тек. ЯП на 1 "вперед" |
| PREVC | **<** | 0x13 | Сдвигает указатель тек. ЯП на 1 "назад" |
| JR | **\[** | 0x14:SE | Если значение тек. ЯП равно нулю тогда выполняет переход по COM на std_se_dec(SE) "вперед" |
| JL | **\]** | 0x15:SE | Если значение тек. ЯП **не** равно нулю тогда выполняет переход по COM на std_se_dec(SE) "назад" |
| CR | **c** | 0x16 | Создает после тек. ЯП дополнительную ЯП и переходит на нее, если выполнены условия У1, иначе программа аварийно завершается |
| DEL | **d** | 0x17 | Удаляет тек. ЯП и переходит на предыдущую, если выполнены условия У2, иначе программа аварийно завершается | 
| ! LSH | **\*** | 0x20 | Битовый сдвиг тек. ЯП влево на 1. Иначе, умножение значения тек. ЯП на 2. |
| ! RSH | **/** | 0x21 | Битовый сдвиг тек. ЯП вправо на 1. Иначе, целочисленное деление значения тек. ЯП на 2. |
| ! AND | **&** | 0x22 | Значения тек. ЯП становится равно наименьшиму значимому биту тек. ЯП |
| ! BND | TODO | 0x23 | Значения тек. ЯП становится равно наиболее значимому биту тек. ЯП |
| ! ZER | **0** | 0x24 | Обнуляет значение тек. ячейки, аналогично \[-\] |
| ! CL | **$** | 0x25 | Копирует значение тек. ЯП в след. ЯП |
| ! TZ | **z** | 0x26 | Если значение тек. ЯП было 0 то не оказывает эффекта, иначе в тек. ЯП записывается 1 |
###### * Предложенное имя операций можно использовать для ассемблера. Если перед именем стоит ! значит убрав все такие операции(не по отдельности а вместе, т.е. одновременно убрав все LSH, RSH, ZER, CL, ...) мы все еще можем их реализовать используя оставшиеся(см. examples/proof_of_sugarity_some_cmds/) таким образом данные команды нужны только для ускорения и удобства.
###### COM сокращение для [co]de [m]emory, т.е. для памяти в которой расположен только код
###### CEM сокращение для [ce]ll [m]emory, т.е. для памяти клеток, в которых распологаются промежуточные вычисления   
###### ** если не сказано инного то предполагается что байты расположены в COM 
###### тек - сокращение для "текущий"
###### ЯП - ячейка памяти

#### примечание SWAP:
Меняет местами текущую "клеточную память" и тек. регистры портов.  
Есть обычная CEM и CPU_CEM (которая скорее всего куда меньше (для консоли и экрана достаточно двух клеток)) они и меняются местами.  
В CPU_CEM нету 'c' и 'd'.  
При этом выполняя перенос из текущей ЯП текущей "клеточной памяти" в текущую ЯП новой "клеточной памяти".  
Данная команда (в bf-ext) используется исключительно компилятором и потому не вызовет трудностей у программиста на bf-ext.  
Пример заполнения  
'port-name:console:66'; 0x42 = 66  
CPU_CEM: \[0x00|0x42\] cell_ptr: 0; как видно - устройство экран не подключено, в CPU_CEM\[1\] хранится порт консоли.  
CEM: \[X_0|..|X_N|0x05|0x52|0x00|..\] cell_ptr: N + 1  
bf-ext code: CMD_0 ... CMD_N s > . r > , 
COM: CMD_COMPILED_0 ... CMD_COMPILED_N X  
where X: 
```
SET 
NEXTC 
SWAP NEXTC SET PREVC WR SWAP
READ
NEXTC
; т.к. ранее мы уже устанавливали свопнутый порт в 0x42 то мы могли бы просто написать SWAP READ SWAP но для ясности:
SWAP NEXTC SET PREVC READ SWAP
```

#### условие У1:
CEM указатель стоит на ячеки памяти такой что выполнено одно из условий:
+ после текущей ЯП не существует { созданной ЯП инструкцией 'c' которая не была бы удалена инструкцией 'd' }
+ после тек. ЯП не существует { ЯП которая не созданной инструкцией 'c' но после которой идет ЯП созданная 'c' }  
и при этом { все ЯП созданные 'c' идущие после тек. ЯП ни разу не использовались }  
при этом { если ЯП используется то все ЯП идущие перед ней считаются использованными  }

#### условие У2:
CEM указатель стоит на ячеки памяти такой что одновременно верно следующее:
+ тек. ЯП порождена инструкцией 'c'
+ после текущей ЯП не существует { созданной ЯП инструкцией 'c' которая не была бы удалена инструкцией 'd' }

### Дополнительные обозначения
#### в секции "посл. байтов"
+ бинарная операция A:B означает что после A (или любого элемента из множества A) идет B (любой элемент из множества B)
+ S : Small byte, байт имеющий значение от 0 до 127 включительно [0x00; 0x7F]  
+ B : Big byte, байт имеющий значение от 128 до 255 включительно [0x80; 0xFF]
+ SE : Set of byte sequences - множество последовательностей байтов таких что S in SE, B:SE in SE  
#### in description section
+ std_se_dec(X): стандартное декодирование SE посл. байтов:  
```
sh = 0;
result = 0;
loop 
  {
  byte = get_next_byte();
  result += (byte & max(S)) << sh;
  if byte > max(S) { sh += 7; }
  else { break; } 
  }
return result;
```
